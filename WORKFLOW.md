# GLOMAP Workflow
* Main caller : `/workspace/3DCD/modules/phase_1/scripts/SFM/run_glomap_batch.sh`

This document outlines the high-level pipeline of the GLOMAP-based Structure-from-Motion (SfM) workflow used in this project. GLOMAP is a global SfM system that is generally faster and more robust than incremental SfM (like standard COLMAP) for large datasets, but it operates on a pre-existing database of features and matches.

## Core Concepts: The Frame-Based Architecture
GLOMAP differs from standard COLMAP in how it handles multi-camera systems. Understanding this is crucial for interpreting results and diagnostics.

1.  **The RIG (Hardware Definition):** The physical blueprint of the camera setup (e.g., "Camera 1 is 10cm right of Camera 0").
2.  **The FRAME (Temporal Snapshot):** A specific instance of the Rig at a specific timestamp.
    *   **Crucial Logic:** GLOMAP groups all images captured at the same timestamp into a single `Frame` object.
    *   **Connectivity:** The View Graph connects **Frames**, not just individual images. If *Camera A* in Frame 1 matches *Camera A* in Frame 2, the **entire Frame 1 is connected to Frame 2**.
    *   **Implication:** This acts as a **"Soft Rig Constraint"**. Even if "Hard" rig constraints (fixed extrinsics) are disabled, cameras in the same frame are mathematically locked together in time. A camera with no matches (e.g., looking at the sky) is "carried along" by its siblings in the same frame, preventing it from being dropped.
3.  **The IMAGE (Data):** The actual pixel data, which is a child of a Frame.

## Rig Constraints: Implicit vs. Explicit
GLOMAP offers two ways to handle multi-camera rigs. Understanding the difference is key to choosing the right configuration.

### 1. Implicit Constraint (Default)
*   **Mechanism:** The **Frame-Based Architecture** itself.
*   **Behavior:** When images are grouped into a Frame, they are mathematically forced to move together as a rigid body because the solver only calculates the pose of the *Frame*, not the individual images.
*   **Rig Extrinsics:** Treated as a **Hard Constant**. GLOMAP trusts your initial calibration 100% and will never change it.
*   **Solver Logic:** "Move the whole rig to fit points."
*   **Best For:** Perfect mechanical rigs, pre-calibrated data.

### 2. Explicit Constraint (`USE_RIG_CONSTRAINTS=1`)
*   **Mechanism:** Adds an optimization layer on top of the Frame structure.
*   **Behavior:** Enables `--BundleAdjustment.optimize_rig_poses 1`.
*   **Rig Extrinsics:** Converted from a constant into a **Variable Parameter**. During Bundle Adjustment (Phase 8), the system solves for 3D points and Frame poses, but *also* slightly adjusts the rotation and translation of the cameras within the rig to minimize error.
*   **Solver Logic:** "Move the rig AND tweak camera positions to fit points."
*   **Best For:** Rigs that might flex, or approximate calibrations.
*   **Phase Affected:** Primarily **Phase 8 (Bundle Adjustment)**.

### Summary Table

| Feature | Implicit Constraint (Frame-Based) | Explicit Constraint (`USE_RIG_CONSTRAINTS=1`) |
| :--- | :--- | :--- |
| **Frame Pose** | Optimized | Optimized |
| **Rig Extrinsics** | **Fixed** (Hard Constraint) | **Optimized** (Soft Constraint / Refined) |
| **Solver Logic** | "Move the whole rig to fit points" | "Move the rig AND tweak camera positions to fit points" |

## Phase 1: Prerequisites & Input Preparation
*   **Goal:** Ensure all necessary data structures are in place before launching the reconstruction.
*   **Input:**
    *   **COLMAP Database (`database.db`):** Contains feature extraction and matching results. Generated by `run_colmap.sh`.
    *   **Image Clusters:** Text files listing images for each sub-problem (e.g., `cluster_0_images.txt`). Generated by `run_colmap_creategroups.sh`.
    *   **Source Images:** The raw image files.
*   **Action:**
    *   **Validation:** Checks for the existence of the database, image directory, and cluster files.
    *   **Frame Grouping:** The loader groups images into `Frames` based on filenames or database metadata. This establishes the "Soft Rig Constraint" described above.
    *   **View Graph Construction:** The system loads the `database.db` and constructs the initial `ViewGraph` object.
    *   **Rig Configuration (Optional):** If `USE_RIG_CONSTRAINTS=1`, the system expects the `rig_sensors` table in the database to be populated (via `configure_rig_from_reconstruction.sh`).
*   **Code Reference:**
    *   **Script:** `modules/phase_1/scripts/SFM/run_glomap_batch.sh` (Input Validation section)
    *   **Loader:** `glomap/io/colmap_converter.cc` (`ConvertDatabaseToGlomap`)

## Phase 2: Preprocessing
*   **Goal:** Prepare the view graph for calibration and estimation.
*   **Action:**
    *   **Configuration Update:** Updates image pair configurations based on camera intrinsics (e.g., forcing Essential matrix if intrinsics are known).
    *   **Relative Pose Decomposition:** Decomposes existing Fundamental/Essential matrices into initial relative rotations and translations ($R, t$) where possible. This provides a starting point for the subsequent optimization phases.
    *   **Prior Handling:** Checks the `cameras` table in `database.db` for the `prior_focal_length` flag. If set, the focal length is treated as a hard constraint in subsequent phases.
*   **Code Reference:**
    *   **Processor:** `glomap/processors/view_graph_manipulation.cc` (`DecomposeRelPose`)
    *   **Loader:** `glomap/io/colmap_converter.cc` (Reads `prior_focal_length` from DB)

## Phase 3: View Graph Calibration
*   **Goal:** Refine camera intrinsics (focal length, principal point) using the geometric constraints of the view graph before solving for poses.
*   **Action:**
    *   Formulates a global optimization problem using Ceres Solver.
    *   Optimizes camera parameters to maximize the consistency of pairwise geometries (Fundamental matrices).
    *   **Constraint Enforcement:** If `camera.has_prior_focal_length` is true (from Phase 2), the focal length parameter is set to **constant** (`SetParameterBlockConstant`), preventing the optimizer from changing it. This ensures that manually provided or EXIF-derived focal lengths are respected.
*   **Code Reference:**
    *   **Orchestrator:** `glomap/controllers/global_mapper.cc` (Step 1)
    *   **Estimator:** `glomap/estimators/view_graph_calibration.cc` (`ViewGraphCalibrator::Solve`)

## Phase 4: Relative Pose Estimation
*   **Goal:** Determine the geometric relationship (rotation and translation) between pairs of images.
*   **Action:**
    *   Computes the Essential Matrix for image pairs using the established tracks.
    *   **Relaxed Constraints:** We use looser thresholds to maintain connectivity in difficult datasets (e.g., water surfaces, repetitive textures).
*   **Key Configuration:**
    *   `--RelPoseEstimation.max_epipolar_error 3.0`: 
        *   *Adjustment:* Relaxed from default (1.5) to 3.0 pixels. This accepts matches that are slightly less precise, helping to bridge gaps in the view graph.
    *   `--Thresholds.min_inlier_num 10`: 
        *   *Adjustment:* Lowered from 15 to 10. Allows pairs with fewer common points to be considered "connected".
    *   `--Thresholds.min_inlier_ratio 0.10`: 
        *   *Adjustment:* Lowered from 0.15 to 0.10. Accepts pairs even if 90% of matches are outliers, provided the geometric core is sound.
*   **Code Reference:**
    *   **Orchestrator:** `glomap/controllers/global_mapper.cc`
    *   **Estimator:** `glomap/estimators/relpose_estimation.cc` (`EstimateRelativePoses`)
    *   **Filter:** `glomap/processors/relpose_filter.cc` (`FilterInlierNum`, `FilterInlierRatio`)

## Phase 5: Rotation Averaging
*   **Goal:** Solve for the global orientation of every camera.
*   **Action:**
    *   Takes pairwise relative rotations and solves a global optimization problem to find absolute rotations.
    *   **Frame-Based Optimization:** The solver estimates the rotation of the **Frame** (`frame.RigFromWorld()`), not individual images.
        *   *Soft Constraint:* All cameras in the same frame are forced to rotate together.
        *   *Benefit:* A camera with weak connections is stabilized by the rotation of its frame-mates.
    *   Runs multiple times with filtering in between to remove bad edges from the view graph.
*   **Checkpoint:** `checkpoint_rotation`
    *   **Location:** `[output_path]/checkpoint_rotation/`
    *   **Files:** `cameras.bin`, `images.bin`, `points3D.bin`
    *   Saved after this phase completes.
    *   Contains: Global rotations for all cameras.
    *   Resume: If found, GLOMAP skips Phases 2-5 and loads these rotations directly.
*   **Code Reference:**
    *   **Controller:** `glomap/controllers/rotation_averager.cc` (`SolveRotationAveraging`)
    *   **Estimator:** `glomap/estimators/global_rotation_averaging.cc`

## Phase 6: Track Establishment
*   **Goal:** Convert pairwise feature matches into global feature tracks.
*   **Action:**
    *   Aggregates pairwise matches from the database into a graph structure.
    *   Performs transitive closure (if A matches B, and B matches C, then A-B-C is a track).
    *   **Filtering:** Discards tracks that are too short or inconsistent.
*   **Checkpoint:** `checkpoint_tracks`
    *   **Location:** `[output_path]/checkpoint_tracks/`
    *   **Files:** `cameras.bin`, `images.bin`, `points3D.bin`
    *   Saved after this phase completes.
    *   Contains: The full track graph (feature correspondences across multiple images).
    *   Resume: If found, GLOMAP skips Phases 2-6.
*   **Key Configuration:**
    *   `--TrackEstablishment.min_num_view_per_track 2`:  
        *   *Adjustment:* Lowered to 2 (default is often 3) to retain more data, especially in sparse areas or video sequences where overlap might be sequential.
    *   `--TrackEstablishment.max_num_view_per_track 100`: Limits the depth of tracks to manage memory.
*   **Code Reference:**
    *   **Controller:** `glomap/controllers/track_establishment.cc` (`TrackEngine`)
    *   **Filter:** `glomap/processors/track_filter.cc`

## Phase 7: Global Positioning
*   **Goal:** Solve for the absolute position of all cameras simultaneously.
*   **Action:**
    *   Uses the computed global rotations and pairwise translations to solve for camera centers.
    *   **Optimization:** Uses **Ceres Solver** to perform a non-linear least squares optimization.
    *   **Frame-Based Optimization:** Similar to Phase 5, the solver optimizes the **Frame Position** (`frame.RigFromWorld().translation`).
        *   Individual camera positions are derived as `Frame_Position + Rotation * Rig_Offset`.
    *   **Technique:** Minimizes a cost function combining:
        *   **Camera-to-Camera Constraints:** `BATAPairwiseDirectionError` (Aligns global camera centers with pairwise relative translation directions).
        *   **Point-to-Camera Constraints:** Aligns observed feature directions with the vector from camera center to 3D point.
    *   **Initialization:** Randomly initializes camera positions before optimization to avoid local minima.
    *   **GPU Acceleration:** Heavily utilizes the GPU for solving large linear systems.
    *   **Filtering & Data Flow:**
        *   **Solver Set:** The solver uses a subset of high-quality tracks (e.g., top 500k) to determine poses.
        *   **Working Set Filtering:** Once poses are found, the system applies geometric constraints (angle error, reprojection error) to the **Working Set** (all tracks established in Phase 6).
        *   *Note:* This step does **not** go back to the full unfiltered dataset to find new tracks; it only filters the existing Working Set.
        *   **Output:** The filtered **Working Set** is passed to Phase 8 for Bundle Adjustment.
*   **Checkpoint:** `checkpoint_gp`
    *   **Location:** `[output_path]/checkpoint_gp/`
    *   **Files:** `cameras.bin`, `images.bin`, `points3D.bin`
    *   Saved after this phase completes.
    *   Contains: Global positions (centers) and rotations for all cameras.
    *   Resume: If found, GLOMAP skips Phases 2-7 and proceeds directly to Bundle Adjustment.
*   **Key Configuration:**
    *   `--GlobalPositioning.use_gpu 1`: Enables CUDA acceleration.
    *   `--GlobalPositioning.max_num_tracks 500000`:
        *   *New Feature:* Limits the number of tracks used in the solver to prevent 32-bit integer overflow (Jacobian size limit in Ceres).
        *   *Logic:* Sorts tracks by length (visibility) and keeps the top N strongest tracks.
    *   `--Thresholds.max_angle_error 4.0`: 
        *   *Adjustment:* Relaxed from 2.0 to 4.0 degrees. Allows for more flexibility in the initial global alignment.
*   **Code Reference:**
    *   **Estimator:** `glomap/estimators/global_positioning.cc` (`GlobalPositioner::Solve`)

## Phase 8: Bundle Adjustment & Refinement
*   **Goal:** Refine the structure (3D points) and motion (camera parameters) to minimize reprojection error.
*   **Action:**
    *   Performs a global non-linear optimization on the entire reconstruction.
    *   **Optimization:** Uses **Ceres Solver** (specifically `SPARSE_SCHUR` linear solver).
    *   **Frame-Based Optimization:** The primary parameter blocks are the **Frame Poses**.
        *   If `optimize_rig_poses` is enabled, the solver *also* refines the `Rig_Offset` for each camera.
        *   If disabled, `Rig_Offset` is treated as constant, but the cameras still move together via the Frame.
    *   **Technique:** Minimizes the reprojection error (difference between projected 3D points and observed 2D features).
    *   **Rig Constraints (Optional):** If `USE_RIG_CONSTRAINTS=1`, GLOMAP incorporates rig information from the database.
*   **Key Configuration:**
    *   `--BundleAdjustment.optimize_rig_poses 1`: 
        *   *Note:* Only active if rig constraints are enabled. Allows the rig extrinsics to "flex" slightly during optimization.
    *   `--BundleAdjustment.max_num_tracks 3000000`:
        *   *New Feature:* Limits the number of tracks used in Bundle Adjustment to manage memory usage and prevent solver crashes.
        *   *Logic:* Similar to Global Positioning, it prioritizes the most visible tracks.
*   **Code Reference:**
    *   **Estimator:** `glomap/estimators/bundle_adjustment.cc` (`BundleAdjuster::Solve`)

## Phase 9: Retriangulation
*   **Goal:** Improve the density and accuracy of the 3D structure by re-triangulating points using the refined camera poses.
*   **Action:**
    *   Uses the refined camera poses from Phase 7 to identify new matches or improve existing ones.
    *   Triangulates new 3D points that satisfy geometric consistency.
    *   Followed by another round of Bundle Adjustment and filtering.
*   **Key Configuration:**
    *   `--skip_retriangulation 0`: Ensures points are retriangulated for maximum density.
    *   `--Thresholds.min_triangulation_angle 0.3`: 
        *   *Adjustment:* Relaxed from 0.5 to 0.3 degrees.
*   **Code Reference:**
    *   **Controller:** `glomap/controllers/track_retriangulation.cc` (`RetriangulateTracks`)

## Phase 10a: Reconstruction Pruning
*   **Goal:** Remove low-quality data to ensure a clean clean final output.
*   **Action:**
    *   Prunes weakly connected images and tracks that do not meet the quality criteria after all optimizations.
*   **Code Reference:**
    *   **Processor:** `glomap/processors/reconstruction_pruning.cc`

## Phase 10b: Final Output Generation (Internal)
*   **Goal:** Save the final reconstruction to disk with color information.
*   **Context:** This is the final internal step of the GLOMAP executable before control returns to the `run_glomap_batch.sh` script.
*   **Action:**
    *   The GLOMAP executable calls `WriteGlomapReconstruction` with the provided `image_path`.
    *   **Coloring:** Unlike intermediate checkpoints (which are saved without colors to save time), this final step reads the original images and assigns RGB colors to the 3D points.
    *   **Result:** The `points3D.bin` file in the root output directory is fully colored.
*   **Code Reference:**
    *   **Executable:** `glomap/exe/global_mapper.cc`
    *   **IO:** `glomap/io/colmap_io.cc`

## Phase 11: Export & Conversion
*   **Goal:** Convert the binary GLOMAP output into human-readable formats and standard point clouds for visualization.
*   **Action:**
    *   **TXT Conversion:** Uses `colmap model_converter` to convert binary files to text (`cameras.txt`, `images.txt`, `points3D.txt`).
    *   **PLY Export:** Uses `colmap model_converter` to export the sparse point cloud as `sparse_pointcloud.ply`.
    *   **Persistence:** Copies all results from the temporary workspace (`/tmp/colmap_workspace`) to the persistent shared data directory (`/workspace/3DCD/shared_data/phase_1/output/cluster_X`).
*   **Output:**
    *   `cameras.txt`, `images.txt`, `points3D.txt`
    *   `sparse_pointcloud.ply`
*   **Code Reference:**
    *   **Script:** `modules/phase_1/scripts/SFM/run_glomap_batch.sh` (Export section)

## Output Directory Structure Reference
The `[output_path]` (configured as `SPARSE_BASE_DIR/cluster_X`) will contain the following structure upon completion:

```text
[output_path]/
├── cameras.bin                 # FINAL RECONSTRUCTION - Camera intrinsics
├── images.bin                  # FINAL RECONSTRUCTION - Image poses (extrinsics)
├── points3D.bin                # FINAL RECONSTRUCTION - 3D structure
├── checkpoint_gp/              # Checkpoint: Global Positioning
│   ├── cameras.bin
│   ├── images.bin
│   ├── points3D.bin
│   └── view_graph.bin
├── checkpoint_tracks/          # Checkpoint: Track Establishment
│   ├── cameras.bin
│   ├── images.bin
│   ├── points3D.bin
│   └── view_graph.bin
├── checkpoint_rotation/        # Checkpoint: Rotation Averaging
│   ├── cameras.bin
│   ├── images.bin
│   ├── points3D.bin
│   └── view_graph.bin
├── text/                       # Converted Text Output
│   ├── cameras.txt
│   ├── images.txt
│   └── points3D.txt
└── sparse_pointcloud.ply       # Visualization Point Cloud
```

## Phase 12: Quality Analysis & Visualization
*   **Goal:** Assess the quality of the reconstruction and generate visual aids.
*   **Action:**
    *   **Quality Metrics:** Runs `analyze_reconstruction_quality.py` to calculate statistics like:
        *   Number of registered images.
        *   Reprojection error.
        *   Track lengths.
    *   **Camera Visualization:** Runs `generate_filtered_camera_ply.py` to create a PLY file representing camera frustums/positions (`cameras.ply`).
*   **Output:**
    *   Analysis logs in the cluster log file.
    *   `cameras.ply` in the output directory.
*   **Code Reference:**
    *   **Analysis:** `modules/phase_1/scripts/analyze_reconstruction_quality.py`
    *   **Visualization:** `modules/phase_1/scripts/generate_filtered_camera_ply.py`

## Memory Management & Large Scale Reconstruction
For very large datasets (e.g., >10 million tracks), the standard pipeline may crash due to:
1.  **Integer Overflow:** The Ceres Solver uses 32-bit integers for indexing the Jacobian matrix. If `num_residuals * num_parameter_blocks` exceeds $2^{31}-1$, it crashes.
2.  **RAM Exhaustion:** Storing the full problem structure can consume hundreds of GBs of RAM.

**Strategy:**
*   **Track Establishment:** We allow a large number of tracks to be initially established (e.g., 10M+) to ensure we capture all potential geometry.
*   **Solver Pruning:** We enforce strict limits (`max_num_tracks`) at the **Global Positioning** and **Bundle Adjustment** stages.
    *   The system sorts all available tracks by their "strength" (number of observations).
    *   It selects the top $N$ tracks (e.g., 3,000,000) to build the optimization problem.
    *   This ensures the solver stays within safe limits while using the best available data.
*   **Iterative Solver (New Feature):**
    *   **Problem:** The default `SPARSE_SCHUR` solver builds a dense Schur complement matrix in RAM, which is $O(N^2)$ and causes OOM crashes for >2M tracks.
    *   **Solution:** We modified `global_positioning.cc` and `bundle_adjustment.cc` to automatically switch to `ITERATIVE_SCHUR` with `SCHUR_POWER_SERIES_EXPANSION` preconditioner when `tracks.size() > 200,000`.
    *   **Benefit:** This solver is "matrix-free" (does not build the dense matrix), reducing memory usage from >250GB to <32GB for large problems.
    *   **Revert Instructions:** To disable this behavior and return to the default solver (if you have >512GB RAM), edit `glomap/estimators/global_positioning.cc` and `glomap/estimators/bundle_adjustment.cc`. Remove the `if (tracks.size() > 200000)` block and force `linear_solver_type = ceres::SPARSE_SCHUR`.
*   **Configuration:**
    *   `MAX_TRACKS_GP`: Controls Global Positioning limit.
    *   `MAX_TRACKS_BA`: Controls Bundle Adjustment limit.
    *   These are configured in `run_glomap_batch.sh`.
